%% LaTeX2e class for student theses
%% sections/content.tex
%%
%% Karlsruhe University of Applied Sciences
%% Faculty of  Computer Science and Business Information Systems
%% Distributed Systems (vsys)
%%
%% Prof. Dr. Christian Zirpins
%% christian.zirpins@hs-karlsruhe.de
%%
%%
%% Version 0.2, 2017-11-15
%%
%% --------------------------------------------------------
%% | Derived from sdqthesis by Erik Burger burger@kit.edu |
%% --------------------------------------------------------
\chapter{Entwurf einer Lösung für Server-zu-Server Interaktion mit ActivityPub}
	Zu Beginn dieses Kapitels wird auf die Entwurfsentscheidung eingegangen und folgende Frage beantwortet:
	\begin{itemize}
		\item Warum wurde die im folgenden beschriebene Architektur gewählt?
	\end{itemize}
	Darauffolgend wird konkret auf die technische Architektur eingegangen und mit Diagrammen veranschaulicht wie diese aussieht.
\section{Entwurfsentscheidung}
	Für die nachfolgende beschriebene Architektur wurde sich in dieser Arbeit entschieden aufgrund des Modularen Charakters. Dies ist gegeben durch die Kapselung des Services in eine Express Middleware. Sowohl das alleinstehende betreiben des Services ist möglich, als auch die Integration in einen bestehen Express Server. Voraussetzung ist eine Implementierung des IDataSource Interfaces zur Anbindung an eine Datenquelle.\\
	
	Es wurde sich für das Erstellen von Nutzern für jeden Aktor des Fediverse, welches mit dieser Instanz kommuniziert, entschieden, da dadurch die automatische Erstellung von Beziehungen erhalten bleibt.
\section{Technische Architektur}
	Die technische Architektur ist in drei Schichten aufgeteilt. Der \textit{ Controller}~hat die Aufgabe HTTP Anfragen entgegen zu nehmen. In der \textit{Service} Schicht bekommen alle Methoden eine Aktivität als Parameter übergeben. Zudem nutzen alle Service Methoden die IDataSource Implementierung. Diese stellt die \textit{Datenschicht} dar.\\
	
	Der ActivityPub Service wird als Express Middleware, sowie als allein stehender Web Server bereitgestellt. Bei der letzteren Variante wird anstatt die Middleware in ein bestehenden Express Server zu integrieren, ein eigener  Server gestartet.\\
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.6]{figures/technische-architektur-activitypub.png}
		\label{technische-architektur-activitypub}
		\caption{Technische Architektur ActivityPub}
	\end{figure}
	In der oben gezeigten Abbildung wurde der ActivityPub Service in einen bestehenden Express Server einer GraphQL API integriert.\\
	
	Benutzer der API kommunizieren mit dem Web Server über das HTTP Protokoll. Der Web Server leitet die Anfragen dann an den entsprechenden Router weiter, welcher wiederum den Anfrage Inhalt transformiert und \glqq Handler\grqq~Funktionen der Service Schicht, mit entsprechenden Parametern, aufruft.
	\begin{figure}[h]
		\begin{minipage}{\textwidth}
			\centering
			\includegraphics[scale=0.6]{figures/Technische-Architektur-standalone.png}
			\label{technische-architektur-standalone}
			\caption{Technische Architektur als allein stehender Server}
		\end{minipage}
	\end{figure}
	Die obige Abbildung zeigt eine detailliertere Variante des ActivityPub Service Diagramms aus Abb. \ref{technische-architektur-activitypub}.\\
	
	Der Router stellt hier die Controller Schicht dar bei der die HTTP Anfragen der Nutzer eingehen und die ActivityPub Komponente ist der eigentliche Service und stellt zudem die gleich benannte Schicht dar.\\
	
	Bei der Architektur wird weitestgehend darauf Wert gelegt, dass die meisten ActivityPub konformen Inhalte dynamisch generiert werden können. Damit wird außerdem versucht für bestehende Projekte die diesen Prototypen integrieren wollen einen einfachen Einstieg zu bieten um andere Datenbanken o.ä. anbinden zu können.\\