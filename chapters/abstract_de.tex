%% LaTeX2e class for student theses
%% sections/abstract_de.tex
%%
%% Karlsruhe University of Applied Sciences
%% Faculty of  Computer Science and Business Information Systems
%% Distributed Systems (vsys)
%%
%% Prof. Dr. Christian Zirpins
%% christian.zirpins@hs-karlsruhe.de
%%
%%
%% Version 0.2, 2017-11-15
%%
%% --------------------------------------------------------
%% | Derived from sdqthesis by Erik Burger burger@kit.edu |
%% --------------------------------------------------------


\Abstract
In dieser Arbeit wurde der ActivityPub Standard und die damit in Verbindung stehenden Standards, Protokolle sowie Netzwerke angesehen. ActivityPub ist generell in zwei Protokoll Schichten aufgeteilt. Die Client-zu-Server Interaktionen sind in der \glqq Social API\grqq~festgehalten und im \glqq federated Server-zu-Server\grqq~Protokoll sind Interaktionsmöglichkeiten für Server untereinander festgehalten. ActivityPub baut auf das Datenformat ActivityStreams 2.0 auf. Dieses besteht, wie auch ActivityPub, aus zwei Teilen. Zum einen dem Kernvokabular, welches Grundlegende Modelle festlegt und zum anderen das eigentliche Vokabular, deren Modelle die des Kernvokabulars erweitern. Jedes Modell in ActivityStreams 2.0 wird wiederum als JSON Linked Data Objekt repräsentiert um eine maschinenlesbare Form des Inhalts zu haben und darüber auch Links zwischen Inhalten auf verschiedenen Webseiten zu erstellen.\\

Mit dem gesammelten Wissen wurde ein Framework entwickelt um eine möglichst einfache Integration des ActivityPub Protokolls in eine bestehende Applikation zu ermöglichen. Die Entwicklung des Frameworks zur ActivityPub Integration beschränkt sich auf die Bereitstellung einer drei Schichten Architektur mit der Datenschicht als Interface. Schicht 1 (\textit{Controller}) beinhaltet Router, welche Funktionalität bereitstellen um ActivityPub konform Inhalte bereitzustellen und zu verarbeiten. Schicht Nummer 2 (\textit{Service}) nimmt Aktivitäten entgegen und holt sowie speichert Inhalte über das IDataSource Interface (\textit{Datenschicht}). In dieser Schicht wird eine Datenbank oder z. B. eine GraphQL Schnittstelle, wie in dieser Arbeit verwendet, angesprochen um Änderungen an einem Datenbestand durchzuführen oder Inhalte zum Bereitstellen zu erhalten.\\

Zur Authentifizierung der Server untereinander sowie zum Sicherstellen der Datenintegrität werden HTTP-Signaturen verwendet. Hierbei wird für jeden Benutzer ein Schlüsselpaar eines öffentlichen Schlüssel Verfahrens generiert. Mit diesem können dann die Anfragen signiert sowie verifiziert werden.\\

Für die Signierung sowie Verifizierung wurde eine Performanz-Messung durchgeführt. Diese wurde erstens auf einem Notebook mit 2-Kernen und zweitens auf einem Desktop-Computer mit 16-Kernen durchgeführt. Die Ergebnisse wurden diskutiert und Empfehlungen zu Hashfunktionen abgegeben die Verwendung finden sollten.